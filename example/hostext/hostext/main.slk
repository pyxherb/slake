module hostext;

import hostext.extfns;

/*attribute TestAttribute {
	let test: i32;
}

interface ICA {
	fn a() virtual;
}

interface ICB {
	fn a() virtual;
}

interface ICC {
	fn a() virtual;
}

class C: ICA + ICB + ICC {
	fn a() virtual override ICA {
	}

	fn a() virtual override ICB {
	}

	fn a() virtual override ICC {
	}
}

struct SA {
	public let a: i32;
	public let b: u32;
	public let c: f32;
}

interface IA {
	public fn testIA() virtual;
}

interface IB {
	public fn testIB() virtual;
}

class ImplTest: IA + IB {
	fn testIA() virtual {
		extfns.print("Called testIA");
	}

	fn testIB() virtual {
		extfns.print("Called testIB");
	}
}

class InterfaceTest<T: IA + IB> {
	fn test(instance: T) {
		(instance as IA).testIA();
		(instance as IB).testIB();
	}
}

class TestParent<T> {
	public fn myTest(a: T, b: T) {
		with T(i32) {
			a + b;
			extfns.print("T = i32\n");
		}
		extfns.print("Called myTest: ", a, " ", b, "\n");
		return;
	}
}

class TestDerived<T>(TestParent<T>) {
	fn myTest() {
		return;
	}
	fn myTest(a: T) {
		return;
	}
}

class AnotherGeneric<X, U> {
	class ChildGeneric<V, T(Test)> {
		public let xyz: i32;

		public fn _setX(abc: T) {
			this.xyz = abc.getX();
			extfns.print("[ChildGeneric]setX: ", this.xyz, "\n");
			return;
		}

		public fn _getX() -> i32 {
			extfns.print("[ChildGeneric]Fetched xyz: ", this.xyz, "\n");
			return this.xyz;
		}
	}
}

class Test {
	public let x: i32;
	public let lab: Test;

	public operator delete() {
		extfns.print("Destructing Test...\n");
		return;
	}

	public operator new(x: i32) {
		this.x = x;
		return;
	}

	public fn getX() -> i32 {
		extfns.print("Fetched x: ", this.x, "\n");
		return this.x;
	}

	public fn test(x: i32&) {
		x = 114514;
		return;
	}

	fn testFunc(x: i32, y: i32) {
		extfns.print("Called testFunc from Test");
		return;
	}

	public operator +(rhs: i32) -> i32 {
		return this.x + rhs;
	}
}

class Derived(Test) {
	public let y: i32;

	public operator delete() {
		extfns.print("Destructing Derived...\n");
		return;
	}

	public operator new(y: i32) {
		this.x = y * 2;
		this.x = y * 4;
		return;
	}

	public fn getY() -> i32 {
		extfns.print("Fetched y: ", this.y, "\n");
		return this.y;
	}

	public fn testFunc(x: i32) {
		extfns.print("Called testFunc from Derived");
		return;
	}
}

class VirtualBase {
	public fn testBase(test: i32) virtual {
		extfns.print("Called VirtualBase's test\n");
		return;
	}
}

class VirtualDerived(VirtualBase) {
	public fn testBase(test: i32) virtual {
		extfns.print("Called VirtualDerived's test\n");
		return;
	}
}

fn genericFn<T, U>(t: T, u: U) {
	return;
}

fn genericFn<U, T>(t: T, u: U) {
	return;
}

fn test(...) {
	//let sv: i32&& = alloca i32[123];
	//...;
	return;
}

// let a: fn (i32, u32, f32) with hostext.VirtualBase -> bool;

class OperatorTest {
	public operator +(lhs: i32, ...) -> i32 {
		return lhs + 114514;
	}
}

fn t() {
	let test: OperatorTest;

	123456 + test;
}

fn valueGenericParamTest<T as i32>() {
}

//class CallableTest<...T> {
//	fn call(test: ...T) {
//		extfns.print("Called CallableTest, values: ", ...test, "\n");
//		return;
//	}
//}

//fn t2() -> simd_t<i32, (4 + 8)> {
//}

class ArgTest<T as i32> {
}

enum union UnionEnum {
	A(a: i32, b: u32, c: f32)
}

enum const ConstEnum {
	a = 123,
	b = 456,
	c = 789,
	d
}

enum const ConstTypedEnum(i32) {
	x = 0xabc,
	b = 0xdef,
	c = 0x123,
	d
}

enum ScopedEnum {
	a = 123,
	b = 456,
	c = 789,
	d
}

enum ScopedTypedEnum(i32) {
	x = 0xabc,
	b = 0xdef,
	c = 0x123,
	d
}

public async main() -> i32 {
	//let se: UnionEnum, sce: ScopedEnum, scte: ScopedTypedEnum;
	//a() with 123;

	let s: SA;

	s.a = 12345678;
	s.b = 45678901;
	s.c = 78901234;

	hostext.extfns.print("Entered main\n");

	let vt: VirtualBase = new VirtualDerived();

	vt.testBase(123);

	let testDerived: TestDerived<i32> = new TestDerived<i32>();

	testDerived.myTest(123, 456);

	let test: Derived = new Derived(1);
	test.lab = test;

	test.testFunc(123, 456);

	let x: AnotherGeneric<i32, f32>.ChildGeneric<f32, Test> = new AnotherGeneric<i32, f32>.ChildGeneric<f32, Test>();
	x._setX(test);
	x._getX();

	extfns.print(test + 123);

	let v: u32 = 1919810 + 0;

	let array: i32[] = { 12, 34, 56, 78, 114, 514, 1919, 810 };
	v = array[2] as u32;

	extfns.print("Value:", v, "\n");

	while(test.x = test.x - 1) {
		extfns.print("Yielded\n");
		yield test.getX();
	}

	1 <=> 1;

	extfns.print("Match result:", match const (123) -> i32 {
		123: 0xffff,
		456: 0x0000,
		789: 0xf0f0,
		default: 0x0f0f
	});

	switch (123) {
		case 456:
			extfns.print("Matched 456\n");
		case 789:
			extfns.print("Matched 789\n");
		case 123:
			extfns.print("Matched 123\n");
		default:
			extfns.print("Default\n");
	}

	let implTest: ImplTest = new ImplTest();

	let interfaceTest: InterfaceTest<ImplTest> = new InterfaceTest<ImplTest>();

	//let callableTest: CallableTest<(i32, u32, f32)>;

	//callableTest.call(114, 514 as u32, 1919810.0f);

	//match const (123) -> i32 {
	//	456: 789,
	//	abc: 0xdef
	//};

	hostext.extfns.print(s.a, "\n");
	hostext.extfns.print(s.b, "\n");
	hostext.extfns.print(s.c, "\n");

	return 114514;
}*/

public fn fib(n: u64) -> u64 {
	if (n < 1)
		return 0 as u64;
	else if (n < 3)
		return 1 as u64;
	return fib(n - 1) + fib(n - 2);
}

public async main() -> i32 {
	extfns.print("fib(30)=", fib(30));
	return 0;
}
