module hostext;

use {
	extfnsModule = hostext.extfns
}

class AnotherGeneric<T, U> {
	class ChildGeneric<V, T> {
		pub let x: T;

		pub fn setX(T x) {
			this.x = x;
			return;
		}

		pub fn getX(): T {
			extfnsModule.print("Fetched x: ", this.x, "\n");
			return this.x;
		}
	}
}

class Test {
	pub let x: i32;
	pub let lab: Test;

	pub operator delete() {
		extfnsModule.print("Destructing Test...\n");
		return;
	}

	pub operator new(i32 x) {
		this.x = x;
		return;
	}

	pub fn getX(): i32 {
		extfnsModule.print("Fetched x: ", this.x, "\n");
		return this.x;
	}
	
	pub operator +(i32 rhs) : i32 {
		return this.x + rhs;
	}
}

class Derived(Test) {
	pub let y: i32;

	pub operator delete() {
		extfnsModule.print("Destructing Derived...\n");
		return;
	}

	pub operator new(i32 y) {
		this.x = y * 2;
		this.x = y * 4;
		return;
	}

	pub fn getY(): i32 {
		extfnsModule.print("Fetched y: ", this.y, "\n");
		return this.y;
	}
}

class AnotherDerived(Derived) {
	pub let z: i32;

	pub operator new(i32 z) {
		this.z = z;
		this.x = z * 4;
		this.y = z * 2;
		return;
	}

	pub fn getZ(): i32 {
		extfnsModule.print("Fetched z: ", this.z, "\n");
		return this.y;
	}
}

class Unrelated {
}

let n : AnotherDerived;

pub fn main(): i32 {
	hostext.extfns.print("Entered main\n");

	let x: AnotherGeneric<i32, f32>.ChildGeneric<f32, i32> = new AnotherGeneric<i32, f32>.ChildGeneric<f32, i32>();
	x.setX(123);
	x.getX();

	let test: Test = new Derived(50);
	test.lab = test;
	test.lab.lab.getX();

	extfnsModule.print(test + 123);

	let array: i32[] = new i32[](32);

	while(test.x = test.x - 1) {
		extfnsModule.print("Yielded\n");
		yield test.getX();
	}

	return 114514;
}
