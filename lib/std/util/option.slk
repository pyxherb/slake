module core.option;

use {
	except = core.except
}

pub class BadOptionAccessError: core.IException {
	fn what() virtual override: string {
		return "Bad option access";
	}
}

fn _getNullOptionData<T>() = null
with <i8>() {
	return 0 as i8;
} with <i16>() {
	return 0 as i16;
} with <i32>() {
	return 0;
} with <i64>() {
	return 0l;
} with <u8>() {
	return 0 as u8;
} with <u16>() {
	return 0 as u16;
} with <u32>() {
	return 0u;
} with <i64>() {
	return 0ul;
} with <bool>() {
	return false;
} with <f32>() {
	return core.numerics.NAN32;
} with <f64>() {
	return core.numerics.NAN64;
} with <object>() {
	return null;
}

pub class Option<T> {
	T _data;
	bool _hasValue;

	pub fn new() {
		this._hasValue = false;
	}

	pub fn new(T data) {
		this._data = data;
		this._hasValue = true;
	}

	pub fn get(): T {
		if(!_hasValue) {
			throw new BadOptionAccessError();
		}
		return _data;
	}

	pub fn set(T data) {
		this._data = data;
		this._hasValue = true;
	}

	pub fn reset() {
		this._data = _getNullOptionData<T>();
		this._hasValue = false;
	}
}
